package httpclient

import (
	"bytes"
	"html/template"
	"strings"

	"github.com/neo532/apitool/transport/http/xhttp"
)

const (
	empty = "google.protobuf.Empty"
)

var RespTplMap = map[string]string{
	"default": `
message {{ .Reply }}Wraper {
    int32 code = 1;
    string message = 2;
    {{ .Reply }} data = 3;
}`,
}

var serviceTemplate = `
{{- /* delete empty line */ -}}
// Code generated by tool. DO NOT EDIT.
// Command : apitool httpclient {{ .ProtoFileName }}
package {{ .PackageName }}

import (
	{{- if .UseContext }}
	"context"
	{{- end }}
	{{- if .UseIO }}
	"io"
	{{- end }}
	{{/* "encoding/json" */}}
	//"net/http"
	{{- if ne .HasImportTime "" }}
	"time"{{- end }}

	{{- if .GoogleEmpty }}
	"google.golang.org/protobuf/types/known/emptypb"
	{{- end }}

	kithttp "github.com/neo532/apitool/transport/http"
	"github.com/neo532/apitool/transport/http/xhttp"
	"github.com/neo532/apitool/transport/http/xhttp/client"
)

type {{ .Service }}XHttpClient struct {
	*kithttp.XClient
}

func New{{ .Service }}XHttpClient(clt client.Client) (xclt *{{ .Service }}XHttpClient) {
	xclt = &{{ .Service }}XHttpClient{
		XClient: kithttp.NewXClient(clt),
	}

	{{- if ne .DomainsLen 0}}
	domains := map[string]string{ {{ range $env, $domain := .Domains }}
		"{{ $env }}": "{{ $domain }}",
	{{- end }}
	}
	if d, ok := domains[string(clt.Env())]; ok {
		xclt.WithDomain(d)
	}
	{{- end}}
	return
}

{{- $s1 := "google.protobuf.Empty" }}
{{ range .Methods }}
{{- if eq .Type 1 }}
func (s *{{ .Service }}XHttpClient) {{ .Name }}(ctx context.Context, req {{ if eq .Request $s1 }}*emptypb.Empty {{ else }}*{{ .Request }}{{ end }}) (resp{{ if eq .Reply $s1 }} *emptypb.Empty{{ else if eq .RespTpl "" }} *{{ .Reply }}{{ else }} *{{ .Reply }}Wraper{{ end }}, err error) {

	opts := make([]xhttp.Opt, 0, 6)
	opts = append(opts, xhttp.WithUrl(s.Domain+"{{ .Path }}"))
	opts = append(opts, xhttp.WithMethod("{{ .Method }}"))
	{{ if ne .TimeLimit "" }}opts = append(opts, xhttp.WithTimeLimit({{ .TimeLimit }}*time.Second)){{ end }} 
	{{ if ne .RetryTimes "" }}opts = append(opts, xhttp.WithRetryTimes({{ .RetryTimes }})){{ end }}
	{{ if ne .RetryDuration "" }}opts = append(opts, xhttp.WithRetryDuration({{ .RetryDuration }}*time.Second)){{ end }}
	{{ if ne .RetryMaxDuration "" }}opts = append(opts, xhttp.WithRetryMaxDuration({{ .RetryMaxDuration }}*time.Second)){{ end }} 
	{{ if ne .ContentType "" }}opts = append(opts, xhttp.WithContentType({{ .ContentType }})){{ end }} 
	{{ if ne .ContentTypeResponse "" }}opts = append(opts, xhttp.WithContentTypeResponse({{ .ContentTypeResponse }})){{ end }} 
	{{ if ne .RequestEncoder "" }}opts = append(opts, xhttp.WithRequestEncoder({{ .RequestEncoder }})){{ end }} 
	{{ if ne .ResponseDecoder "" }}opts = append(opts, xhttp.WithResponseDecoder({{ .ResponseDecoder }})){{ end }} 
	{{ if ne .ErrorDecoder "" }}opts = append(opts, xhttp.WithErrorDecoder({{ .ErrorDecoder }})){{ end }} 
	{{- if .HasQueryArgs }}
	if ctx, err = xhttp.AppendUrlByStruct(ctx, req); err != nil {
		return
	}
	req = &{{ .Request }}{}
	{{ end }}
	{{ if eq .RespTpl "" }}resp = {{ if eq .Reply $s1 }}&emptypb.Empty{}{{ else }}&{{ .Reply }}{}{{ end }}
	{{ else }}
	resp = &{{ .Reply }}Wraper{}{{ end }}

	err = xhttp.New(s.Client, opts...).Do(ctx, req, resp)
	return 
}

{{- else if eq .Type 2 }}
func (s *{{ .Service }}XHttpClient) {{ .Name }}(conn pb.{{ .Service }}_{{ .Name }}Client) error {
	for {
		req, err := conn.Recv()
		if err == io.EOF {
			return nil
		}
		if err != nil {
			return err
		}
		
		err = conn.Send(&pb.{{ .Reply }}{})
		if err != nil {
			return err
		}
	}
}

{{- else if eq .Type 3 }}
func (s *{{ .Service }}XHttpClient) {{ .Name }}(conn pb.{{ .Service }}_{{ .Name }}Client) error {
	for {
		req, err := conn.Recv()
		if err == io.EOF {
			return conn.SendAndClose(&pb.{{ .Reply }}{})
		}
		if err != nil {
			return err
		}
	}
}

{{- else if eq .Type 4 }}
func (s *{{ .Service }}XHttpClient) {{ .Name }}(req {{ if eq .Request $s1 }}*emptypb.Empty
{{ else }}*pb.{{ .Request }}{{ end }}, conn pb.{{ .Service }}_{{ .Name }}Client) error {
	for {
		err := conn.Send(&pb.{{ .Reply }}{})
		if err != nil {
			return err
		}
	}
}

{{- end }}
{{- end }}
`

type MethodType uint8

const (
	unaryType          MethodType = 1
	twoWayStreamsType  MethodType = 2
	requestStreamsType MethodType = 3
	returnsStreamsType MethodType = 4
)

// Service is a proto service.
type Service struct {
	Package       string
	PackageName   string
	Service       string
	Methods       []*Method
	GoogleEmpty   bool
	Domains       map[string]string
	DomainsLen    int
	TargetDir     string
	ProtoFileName string
	HasImportTime string

	ServiceLower string

	UseIO      bool
	UseContext bool
}

// Method is a proto method.
type Method struct {
	Service  string
	MService string
	Name     string
	Request  string
	Reply    string

	HasQueryArgs bool

	// type: unary or stream
	Type MethodType

	//xhttp opts
	Path                string
	TimeLimit           string
	Method              string
	RetryTimes          string
	RetryDuration       string
	RetryMaxDuration    string
	ContentType         string
	ContentTypeResponse string
	RespTpl             string

	RequestEncoder  string
	ResponseDecoder string
	ErrorDecoder    string
}

func (s *Service) execute() ([]byte, error) {
	buf := new(bytes.Buffer)

	sPackage := strings.Split(s.Package, "/")
	mService := sPackage[len(sPackage)-2]

	for _, method := range s.Methods {
		if xhttp.HasBody(method.Method) == false {
			method.HasQueryArgs = true
		}

		if (method.Type == unaryType && (method.Request == empty || method.Reply == empty)) ||
			(method.Type == returnsStreamsType && method.Request == empty) {
			s.GoogleEmpty = true
		}
		if method.Type == twoWayStreamsType || method.Type == requestStreamsType {
			s.UseIO = true
		}
		if method.Type == unaryType {
			s.UseContext = true
		}
		method.MService = mService
	}

	s.ServiceLower = strings.ToLower(s.Service)

	tmpl, err := template.New("service").Parse(serviceTemplate)
	if err != nil {
		return nil, err
	}
	if err := tmpl.Execute(buf, s); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

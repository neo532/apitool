package httpclient

import (
	"bytes"
	"html/template"
	"strings"

	"github.com/neo532/apitool/transport/http/xhttp"
)

const (
	emptyPb      = "google.protobuf.Empty"
	emptyVarName = "Empty"
	emptyType    = "emptypb.Empty"

	anyPb      = "google.protobuf.Any"
	anyVarName = "Any"
	anyType    = "anypb.Any"

	wrapper = "Wrapper"
)

var serviceTemplate = `
{{- /* delete empty line */ -}}
// Code generated by tool. DO NOT EDIT.
// Command : apitool httpclient {{ .ProtoFileName }}
package {{ .PackageName }}

import (
	{{range $key,$value := .ImportList }}"{{ $key }}"
	{{ end }}
	kithttp "github.com/neo532/apitool/transport/http"
	"github.com/neo532/apitool/transport/http/xhttp"
	"github.com/neo532/apitool/transport/http/xhttp/client"
)

type {{ .Service }}XHttpClient struct {
	*kithttp.XClient
}

func New{{ .Service }}XHttpClient(clt client.Client) (xclt *{{ .Service }}XHttpClient) {
	xclt = &{{ .Service }}XHttpClient{
		XClient: kithttp.NewXClient(clt),
	}

	{{- if ne .DomainsLen 0}}
	domains := map[string]string{ {{ range $env, $domain := .Domains }}
		"{{ $env }}": "{{ $domain }}",
	{{- end }}
	}
	if d, ok := domains[string(clt.Env())]; ok {
		xclt.WithDomain(d)
	}
	{{- end}}
	return
}

{{ range .Methods }}
{{- if eq .Type 1 }}
func (s *{{ .Service }}XHttpClient) {{ .Name }}(ctx context.Context, req *{{ .RequestType }}) (resp *{{ .ReplyType }}, err error) {
	opts := make([]xhttp.Opt, 0, 6)
	opts = append(opts, xhttp.WithUrl(s.Domain+"{{ .Path }}"))
	opts = append(opts, xhttp.WithMethod("{{ .Method }}"))
	{{ if ne .TimeLimit "" }}opts = append(opts, xhttp.WithTimeLimit({{ .TimeLimit }}*time.Second)){{ end }} 
	{{ if ne .RetryTimes "" }}opts = append(opts, xhttp.WithRetryTimes({{ .RetryTimes }})){{ end }}
	{{ if ne .RetryDuration "" }}opts = append(opts, xhttp.WithRetryDuration({{ .RetryDuration }}*time.Second)){{ end }}
	{{ if ne .RetryMaxDuration "" }}opts = append(opts, xhttp.WithRetryMaxDuration({{ .RetryMaxDuration }}*time.Second)){{ end }} 
	{{ if ne .ContentType "" }}opts = append(opts, xhttp.WithContentType({{ .ContentType }})){{ end }} 
	{{ if ne .ContentTypeResponse "" }}opts = append(opts, xhttp.WithContentTypeResponse({{ .ContentTypeResponse }})){{ end }} 
	{{ if ne .RequestEncoder "" }}opts = append(opts, xhttp.WithRequestEncoder({{ .RequestEncoder }})){{ else }}
	if s.RequestEncoder != nil {
		opts = append(opts, xhttp.WithRequestEncoder(s.RequestEncoder))
	}
	{{ end }} 
	{{ if ne .ResponseDecoder "" }}opts = append(opts, xhttp.WithResponseDecoder({{ .ResponseDecoder }})){{ else }}
	if s.ResponseDecoder != nil {
		opts = append(opts, xhttp.WithResponseDecoder(s.ResponseDecoder))
	}
	{{ end }} 
	{{ if ne .ErrorDecoder "" }}opts = append(opts, xhttp.WithErrorDecoder({{ .ErrorDecoder }})){{ else }}
	if s.ErrorDecoder != nil {
		opts = append(opts, xhttp.WithErrorDecoder(s.ErrorDecoder))
	}
	{{ end }} 
	{{ if and (ne .CertFileCrt "") (ne .CertFileKey "") }}
	var certFile xhttp.Opt
	if certFile, err = xhttp.WithCertFile("{{ .CertFileCrt }}", "{{ .CertFileKey }}"); err != nil {
		return
	}
	opts = append(opts, certFile)
	{{ end }} 
	{{ if ne .CaCertFile "" }}
	var caCertFile xhttp.Opt
	if caCertFile, err = xhttp.WithCaCertFile("{{ .CaCertFile }}"); err != nil {
		return
	}
	opts = append(opts, caCertFile)
	{{ end }} 
	{{- if .InsecureSkipVerify }}
	opts = append(opts, xhttp.WithInsecureSkipVerify({{ .InsecureSkipVerify }}))
	{{ end }}
	{{- if .HasQueryArgs }}
	if ctx, err = xhttp.AppendUrlByStruct(ctx, req); err != nil {
		return
	}
	req = &{{ .RequestType }}{}
	{{ end }}
	{{ if eq .ReplyType .AnyTypeKey }}
	resp = &{{ .ReplyType }}{}
	err = xhttp.New(s.Client, opts...).Do(ctx, req, resp)
	{{ else if  eq .ReplyTypeWrapper "" }}
	resp = &{{ .ReplyType }}{}
	err = xhttp.New(s.Client, opts...).Do(ctx, req, resp)
	{{ else }}
	rst := &{{ .ReplyTypeWrapper }}{}
	err = xhttp.New(s.Client, opts...).Do(ctx, req, rst)
	if rst != nil {
		resp = rst.{{ .RespTplDataName }}
	}
	{{ end }} 
	return 
}
{{- end }}
{{- end }}
`

type MethodType uint8

const (
	unaryType          MethodType = 1
	twoWayStreamsType  MethodType = 2
	requestStreamsType MethodType = 3
	returnsStreamsType MethodType = 4
)

// Service is a proto service.
type Service struct {
	//Package     string
	PackageName string
	Service     string
	Methods     []*Method

	NeedClient bool

	Domains       map[string]string
	DomainsLen    int
	TargetDir     string
	ProtoFileName string

	ServiceLower string

	EmptyHas bool
	AnyHas   bool
	//UseIO    bool
	//UseContext    bool
	//HasImportTime string

	ImportList        Import
	PackageDomainList PackageDomain
}

// Method is a proto method.
type Method struct {
	Service string
	Name    string

	// google.protobuf.Empty | google.protobuf.Any | github.com/a.B | B
	Request string
	Reply   string

	// emptypb.Empty | anypb.Any | a.B | B
	RequestType string
	ReplyType   string

	// EmptyWrapper | AnyWrapper | BWrapper
	ReplyTypeWrapper string // anypb & wrappper at same time

	HasQueryArgs bool

	AnyTypeKey string

	// type: unary or stream
	Type MethodType

	//xhttp opts
	Path                string
	TimeLimit           string
	Method              string
	RetryTimes          string
	RetryDuration       string
	RetryMaxDuration    string
	ContentType         string
	ContentTypeResponse string
	RespTpl             string
	RespTplDataName     string

	RequestEncoder  string
	ResponseDecoder string
	ErrorDecoder    string

	CertFileCrt        string
	CertFileKey        string
	InsecureSkipVerify string
	CaCertFile         string
}

func (s *Service) ParsePackageInParam(param string) (paramType, packageName string) {
	if strings.Contains(param, ".") == false {
		paramType = param
		return
	}
	packageName, paramType = s.PackageDomainList.Fix(param)
	return
}

func (s *Service) Alias(m *Method) {
	var pkg string

	// request
	switch m.Request {
	case emptyPb:
		m.RequestType = emptyType
	case anyPb:
		m.RequestType = anyType
	default:
		if m.RequestType, pkg = s.ParsePackageInParam(m.Request); pkg != "" {
			s.ImportList = s.ImportList.Special(pkg)
		}
	}

	// reply
	switch m.Reply {
	case emptyPb:
		m.ReplyType = emptyType
	case anyPb:
		m.ReplyType = anyType
	default:
		if m.ReplyType, pkg = s.ParsePackageInParam(m.Reply); pkg != "" {
			s.ImportList = s.ImportList.Special(pkg)
		}
	}
	if m.RespTpl != "" {
		reply := strings.ReplaceAll(m.ReplyType, wrapper, "")
		rs := strings.Split(reply, ".")
		m.ReplyTypeWrapper = rs[len(rs)-1] + wrapper
	}
}

func (s *Service) execute() ([]byte, error) {
	buf := new(bytes.Buffer)

	for _, method := range s.Methods {

		if xhttp.HasBody(method.Method) == false {
			method.HasQueryArgs = true
		}

		s.Alias(method)

		method.AnyTypeKey = anyType

		switch method.Type {
		case unaryType:
			s.ImportList = s.ImportList.Context()
			if method.Request == anyPb ||
				method.Reply == anyPb {
				s.ImportList = s.ImportList.AnyPB()
			}
			if method.Request == emptyPb ||
				method.Reply == emptyPb {
				s.ImportList = s.ImportList.EmptyPB()
			}
		case twoWayStreamsType, requestStreamsType:
			s.ImportList = s.ImportList.IO()
		case returnsStreamsType:
			if method.Request == anyPb {
				s.ImportList = s.ImportList.AnyPB()
			}
			if method.Request == emptyPb {
				s.ImportList = s.ImportList.EmptyPB()
			}
		}
	}

	s.ServiceLower = strings.ToLower(s.Service)

	tmpl, err := template.New("service").Parse(serviceTemplate)
	if err != nil {
		return nil, err
	}
	if err := tmpl.Execute(buf, s); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

package grpcclient

import (
	"bytes"
	"html/template"
	"strings"
)

var serviceTemplate = `
{{- /* delete empty line */ -}}
// Code generated by tool. DO NOT EDIT.
// Command : apitool grpcclient {{ .ProtoFileName }}
package {{ .ServiceLower }}

import (
	{{- if .UseContext }}
	"context"
	{{- end }}
	{{- if .UseIO }}
	"io"
	{{- end }}

	{{- if .GoogleEmpty }}
	"google.golang.org/protobuf/types/known/emptypb"
	{{- end }}

	"github.com/neo532/apitool/registry"
	"github.com/neo532/apitool/transport/grpc"
	ggrpc "google.golang.org/grpc"
)

type {{ .Service }}GrpcClient struct {
	Unimplemented{{ .Service }}Server
	wrapper *grpc.Wrapper
}

func New{{ .Service }}GrpcClient(dis *registry.Discovery) *{{ .Service }}GrpcClient {
	return &{{ .Service }}GrpcClient{
		wrapper: grpc.NewWrapper(dis),
	}
}

{{- $s1 := "google.protobuf.Empty" }}
{{ range .Methods }}
{{- if eq .Type 1 }}
func (s *{{ .Service }}GrpcClient) {{ .Name }}(ctx context.Context, req {{ if eq .Request $s1 }}*emptypb.Empty
{{ else }}*{{ .Request }}{{ end }}) ({{ if eq .Reply $s1 }}*emptypb.Empty{{ else }}reply *{{ .Reply }}{{ end }}, err error) {
	err = s.wrapper.Call(ctx, "{{ .MService }}", func(c context.Context, conn *ggrpc.ClientConn) (e error) {
		reply, e = New{{ .Service }}Client(conn).{{ .Name }}(ctx, req)
		return e
	})
	return 
}

{{- else if eq .Type 2 }}
func (s *{{ .Service }}GrpcClient) {{ .Name }}(conn pb.{{ .Service }}_{{ .Name }}Client) error {
	for {
		req, err := conn.Recv()
		if err == io.EOF {
			return nil
		}
		if err != nil {
			return err
		}
		
		err = conn.Send(&pb.{{ .Reply }}{})
		if err != nil {
			return err
		}
	}
}

{{- else if eq .Type 3 }}
func (s *{{ .Service }}GrpcClient) {{ .Name }}(conn pb.{{ .Service }}_{{ .Name }}Client) error {
	for {
		req, err := conn.Recv()
		if err == io.EOF {
			return conn.SendAndClose(&pb.{{ .Reply }}{})
		}
		if err != nil {
			return err
		}
	}
}

{{- else if eq .Type 4 }}
func (s *{{ .Service }}GrpcClient) {{ .Name }}(req {{ if eq .Request $s1 }}*emptypb.Empty
{{ else }}*pb.{{ .Request }}{{ end }}, conn pb.{{ .Service }}_{{ .Name }}Client) error {
	for {
		err := conn.Send(&pb.{{ .Reply }}{})
		if err != nil {
			return err
		}
	}
}

{{- end }}
{{- end }}
`

type MethodType uint8

const (
	unaryType          MethodType = 1
	twoWayStreamsType  MethodType = 2
	requestStreamsType MethodType = 3
	returnsStreamsType MethodType = 4
)

// Service is a proto service.
type Service struct {
	Package       string
	Service       string
	Methods       []*Method
	GoogleEmpty   bool
	TargetDir     string
	ProtoFileName string

	ServiceLower string

	UseIO      bool
	UseContext bool
}

// Method is a proto method.
type Method struct {
	Service  string
	MService string
	Name     string
	Request  string
	Reply    string

	// type: unary or stream
	Type MethodType
}

func (s *Service) execute() ([]byte, error) {
	const empty = "google.protobuf.Empty"
	buf := new(bytes.Buffer)

	sPackage := strings.Split(s.Package, "/")
	mService := sPackage[len(sPackage)-2]

	for _, method := range s.Methods {
		if (method.Type == unaryType && (method.Request == empty || method.Reply == empty)) ||
			(method.Type == returnsStreamsType && method.Request == empty) {
			s.GoogleEmpty = true
		}
		if method.Type == twoWayStreamsType || method.Type == requestStreamsType {
			s.UseIO = true
		}
		if method.Type == unaryType {
			s.UseContext = true
		}
		method.MService = mService
	}

	s.ServiceLower = strings.ToLower(s.Service)

	tmpl, err := template.New("service").Parse(serviceTemplate)
	if err != nil {
		return nil, err
	}
	if err := tmpl.Execute(buf, s); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
